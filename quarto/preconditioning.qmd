---
title: Preconditioning
---

\newcommand{\diag}{\operatorname{diag}}
\newcommand{\Diag}{\operatorname{Diag}}
\newcommand{\ip}[1]{\langle #1 \rangle}
****
Each iteration of the preconditioned Newton CG method approximately solves the trust-region subproblem
$$
\min_{s} \{\tfrac{1}{2} \ip{s, H_k s} + \ip{\nabla f_k,s } \mid \|s\|_M \leq \Delta\}
$$
where $\nabla f_k$ and $H_k$ are the current gradient and Hessian, and $M\approx H$ is a positive definite preconditioner. For the KL regularized LS problem,
$$
H_k = A S_k A^T + \lambda I, \quad S_k:= X_k - x_k x_k^T
$$
where $x_k$ is the current primal iterate and $X_k=\Diag(x_k)$.

We consider these preconditioners:

1. Diagonal, constant: $M = \Diag(AA^T) + \lambda I$
1. (not working) Diagonal, variable: $M = \Diag(AX_kA^T) + \lambda I$
1. (not yet implemented) Cholesky, constant: $M = AA^T + \lambda I$

The first two preconditioners have complexity $O(mn)$ to compute and $O(m)$ to apply. The third has cubic complexity, but that cost can be amortized over the Newton iterations.

```{julia}
#| code-fold: true
#| output: false 
using LinearAlgebra, NPZ, StatsPlots
import KLLS: KLLSModel, DiagAAPreconditioner, DiagASAPreconditioner, solve!
```
Load the synthetic UEG test problem:
```{julia}
data = try # needed because of vscode quirks while developing
    npzread("../data/synthetic-UEG_testproblem.npz")
catch
    npzread("./data/synthetic-UEG_testproblem.npz")
end
kldata = KLLSModel(data["A"], data["b_avg"])
```

Build the preconditioner object:
```{julia}
MAA = DiagAAPreconditioner(kldata);
# MASA = DiagASAPreconditioner(kldata) # NOT WORKING! ðŸ˜¢
```

Solve the problem with and without preconditioning:
```{julia}
kldata.Î»=1e-6
statsI = solve!(kldata, trace=true)
statsMAA = solve!(kldata, trace=true, M=MAA)
# statsMASA = solve!(kldata, trace=true, M=MASA)
```

Plot the dual objective value and cumulative CG iterations.
```{julia}
#|echo: false
label = ["no precon" "Diag(AA')"]
pCG = plot([cumsum(statsI.tracer.cgits), cumsum(statsMAA.tracer.cgits)], xlabel="Iteration", ylabel="cumulative CG Iterations", label=label, lw=2)
pObj = plot([
    statsI.tracer.dual_obj,
    statsMAA.tracer.dual_obj],
    xlabel="Iteration",
    ylabel="dual objective",
    label=label, lw=2)
plot(pObj, pCG, layout=(1,2))
```
