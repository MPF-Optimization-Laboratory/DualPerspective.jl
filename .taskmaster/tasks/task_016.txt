# Task ID: 16
# Title: Implement Comprehensive Logging for Gauss-Newton Method
# Status: done
# Dependencies: 9
# Priority: high
# Description: Enhance the existing Gauss-Newton solver with a comprehensive logging system using Julia's standard logging facilities, including appropriate log levels for different types of information and thorough testing.
# Details:
Implement a comprehensive logging system for the Gauss-Newton method using Julia's standard logging framework:

1. Add structured logging at appropriate levels:
   - `@debug` for detailed iteration information:
     ```julia
     @debug "Starting iteration $iter" x=x f=f_val grad_norm=norm(g)
     @debug "Iteration details" step_size=α decrease=Δf
     ```
   - `@info` for high-level progress:
     ```julia
     @info "Starting Gauss-Newton solver" initial_point=x0 initial_value=f0
     @info "Solver converged" iterations=iter f_final=f_val grad_norm=norm(g) time=elapsed_time
     ```
   - `@warn` for convergence issues:
     ```julia
     @warn "Maximum iterations reached without convergence" iter=max_iter grad_norm=norm(g)
     ```

2. Ensure zero-cost performance when debug logging is disabled:
   - Use `@debug` macro which has zero overhead when disabled
   - Add a check in the function documentation showing how to disable debug logging:
     ```julia
     Logging.disable_logging(Logging.Debug)
     ```

3. Update the function docstring to explain logging behavior:
   ```julia
   """
       gauss_newton(model::DPModel, x0::AbstractVector; kwargs...)

   Solve the optimization problem using the Gauss-Newton method.

   # Logging
   This function uses Julia's standard logging system:
   - Debug level: Per-iteration details (disabled by default)
   - Info level: Start and end messages with summary statistics
   - Warn level: Convergence warnings

   To control logging output:
   - Enable debug: `Logging.global_logger(Logging.ConsoleLogger(stderr, Logging.Debug))`
   - Disable all: `Logging.global_logger(Logging.NullLogger())`
   - Zero-cost debug: `Logging.disable_logging(Logging.Debug)` (recommended for production)

   # Arguments
   - `model::DPModel`: The optimization model
   - `x0::AbstractVector`: Initial point

   # Keyword Arguments
   - `max_iter::Int=100`: Maximum number of iterations
   - `tol::Float64=1e-6`: Convergence tolerance
   - ...
   """
   ```

4. Implement the logging in the main solver loop:
   ```julia
   function gauss_newton(model::DPModel, x0::AbstractVector; 
                       max_iter=100, 
                       tol=1e-6,
                       verbose=false)
       x = copy(x0)
       n = length(x)
       
       # Initial evaluation
       f = obj(model, x)
       g = similar(x)
       grad!(model, x, g)
       
       @info "Starting Gauss-Newton solver" initial_point=x0 initial_value=f
       
       # Print header for debug output
       @debug "Gauss-Newton iterations" 
       @debug "Iter      Objective      ||∇f||        Step size     Decrease"
       
       start_time = time()
       
       for iter = 1:max_iter
           @debug "Starting iteration $iter" x=x f=f grad_norm=norm(g)
           
           # Compute search direction using Gauss-Newton approximation
           # ...
           
           # Line search
           α = 1.0
           f_new = obj(model, x + α*d)
           while f_new > f + 0.1*α*dot(g, d) && α > 1e-10
               α *= 0.5
               f_new = obj(model, x + α*d)
           end
           
           # Update
           x_old, f_old = copy(x), f
           x .+= α .* d
           f = f_new
           grad!(model, x, g)
           
           # Log iteration details
           @debug "Iteration $iter complete" objective=f grad_norm=norm(g) step_size=α decrease=(f_old-f)
           
           # Check convergence
           if norm(g) < tol
               elapsed_time = time() - start_time
               @info "Solver converged" iterations=iter f_final=f grad_norm=norm(g) time=elapsed_time
               return x, f, iter, true
           end
       end
       
       # If we get here, we didn't converge
       elapsed_time = time() - start_time
       @warn "Maximum iterations reached without convergence" iter=max_iter grad_norm=norm(g)
       @info "Solver terminated" iterations=max_iter f_final=f grad_norm=norm(g) time=elapsed_time
       
       return x, f, max_iter, false
   end
   ```

5. Add examples to the documentation showing different logging configurations:
   ```julia
   # Examples
   
   # Default usage (Info level only)
   x, f, iters, converged = gauss_newton(model, x0)
   
   # Enable debug output
   using Logging
   Logging.global_logger(Logging.ConsoleLogger(stderr, Logging.Debug))
   x, f, iters, converged = gauss_newton(model, x0)
   
   # Silence all output
   Logging.global_logger(Logging.NullLogger())
   x, f, iters, converged = gauss_newton(model, x0)
   
   # Production setup with zero-cost debug logging
   Logging.disable_logging(Logging.Debug)
   x, f, iters, converged = gauss_newton(model, x0)
   ```

# Test Strategy:
Implement comprehensive tests to verify the logging functionality:

1. Create a test file `test/test_gauss_newton_logging.jl` with the following test cases:

```julia
@testset "Gauss-Newton Logging" begin
    # Setup a simple test problem
    model = create_test_model()
    x0 = ones(model.meta.nvar)
    
    # Test 1: Debug messages appear when debug logging is enabled
    test_log = IOBuffer()
    debug_logger = ConsoleLogger(test_log, Logging.Debug)
    
    Logging.with_logger(debug_logger) do
        gauss_newton(model, x0, max_iter=5)
    end
    
    log_output = String(take!(test_log))
    @test occursin("Starting iteration", log_output)
    @test occursin("Iteration details", log_output)
    
    # Test 2: Debug messages don't appear at Info level
    test_log = IOBuffer()
    info_logger = ConsoleLogger(test_log, Logging.Info)
    
    Logging.with_logger(info_logger) do
        gauss_newton(model, x0, max_iter=5)
    end
    
    log_output = String(take!(test_log))
    @test occursin("Starting Gauss-Newton solver", log_output)
    @test !occursin("Starting iteration", log_output)
    
    # Test 3: Info messages always appear at default level
    test_log = IOBuffer()
    default_logger = ConsoleLogger(test_log)
    
    Logging.with_logger(default_logger) do
        gauss_newton(model, x0, max_iter=5)
    end
    
    log_output = String(take!(test_log))
    @test occursin("Starting Gauss-Newton solver", log_output)
    @test occursin("Solver", log_output)
    
    # Test 4: Warning appears when max iterations reached
    test_log = IOBuffer()
    warn_logger = ConsoleLogger(test_log, Logging.Warn)
    
    Logging.with_logger(warn_logger) do
        # Use a problem that won't converge in 2 iterations
        gauss_newton(model, 100*x0, max_iter=2)
    end
    
    log_output = String(take!(test_log))
    @test occursin("Maximum iterations reached", log_output)
    
    # Test 5: Logging can be completely silenced with NullLogger
    test_log = IOBuffer()
    # First log something to the buffer to ensure it's working
    println(test_log, "Buffer test")
    
    Logging.with_logger(Logging.NullLogger()) do
        gauss_newton(model, x0, max_iter=5)
    end
    
    # Reset position to beginning of buffer
    seekstart(test_log)
    log_output = String(read(test_log))
    @test occursin("Buffer test", log_output)
    @test !occursin("Gauss-Newton", log_output)
    
    # Test 6: Performance is not affected when debug logging is disabled
    Logging.disable_logging(Logging.Debug)
    
    # Warm up
    gauss_newton(model, x0, max_iter=5)
    
    # Time with debug disabled
    t1 = @elapsed gauss_newton(model, x0, max_iter=20)
    
    # Enable all logging and time again
    Logging.disable_logging(Logging.BelowMinLevel)
    test_log = IOBuffer()
    debug_logger = ConsoleLogger(test_log, Logging.Debug)
    
    t2 = @elapsed Logging.with_logger(debug_logger) do
        gauss_newton(model, x0, max_iter=20)
    end
    
    # The performance should be similar when debug is disabled
    # Allow some variation due to system factors
    @test t1 <= t2 * 1.1  # Debug disabled should be at least as fast
end
```

2. Add the test file to the main test suite in `test/runtests.jl`:

```julia
include("test_gauss_newton_logging.jl")
```

3. Verify the tests pass with:

```bash
julia --project -e 'using Pkg; Pkg.test()'
```

4. Manually verify the logging behavior by running examples from the documentation in the REPL and checking the output.

5. Create a benchmark script to verify that there is no performance regression when logging is disabled:

```julia
using BenchmarkTools
using Logging

# Create a test problem
model = create_large_test_model(1000)  # Larger problem for meaningful benchmarks
x0 = ones(model.meta.nvar)

# Benchmark with debug logging disabled (production setting)
Logging.disable_logging(Logging.Debug)
b1 = @benchmark gauss_newton($model, $x0, max_iter=20)

# Benchmark with all logging disabled
Logging.global_logger(Logging.NullLogger())
b2 = @benchmark gauss_newton($model, $x0, max_iter=20)

# Benchmark with debug logging enabled
debug_logger = ConsoleLogger(devnull, Logging.Debug)
Logging.global_logger(debug_logger)
b3 = @benchmark gauss_newton($model, $x0, max_iter=20)

println("With debug disabled: ", median(b1))
println("With all logging disabled: ", median(b2))
println("With debug enabled: ", median(b3))

# The first two should be very close in performance
```
